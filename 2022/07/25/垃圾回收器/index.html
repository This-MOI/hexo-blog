<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1.GC 分类与性能指标   垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。   由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。   从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。 Java 不同版本新特性  语法层面：Lambda 表达式、switch、自动拆箱装箱、enum API 层面：Strea">
<meta property="og:type" content="article">
<meta property="og:title" content="MOITY个人">
<meta property="og:url" content="http://example.com/2022/07/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/index.html">
<meta property="og:site_name" content="MOITY个人">
<meta property="og:description" content="1.GC 分类与性能指标   垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。   由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。   从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。 Java 不同版本新特性  语法层面：Lambda 表达式、switch、自动拆箱装箱、enum API 层面：Strea">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718151310.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718153041.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718153047.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718154118.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718154141.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718160558.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718214825.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718221136.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719101136.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719101216.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719105418.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719105436.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719145208.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719145302.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719145333.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719151759.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719154049.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719154419.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719163120.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220719163143.png">
<meta property="og:image" content="http://moity-bucket.moity-soeoe.xyz/img/ef465d703c93e5b923776ca6469efe63.gif">
<meta property="article:published_time" content="2022-07-25T13:03:07.477Z">
<meta property="article:modified_time" content="2022-07-25T13:03:07.477Z">
<meta property="article:author" content="MOITY">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://moity-bucket.moity-soeoe.xyz/img/20220718151310.png">


<link rel="canonical" href="http://example.com/2022/07/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/07/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","path":"2022/07/25/垃圾回收器/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | MOITY个人</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">MOITY个人</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-GC-%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">1.GC 分类与性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 垃圾收集器分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E6%8C%89%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%88%92%E5%88%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 按线程数划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E6%8C%89%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%88%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 按工作模式分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E6%8C%89%E7%A2%8E%E7%89%87%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%88%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3 按碎片处理方式分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-%E6%8C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E9%97%B4%E5%88%86"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4 按工作的内存区间分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%AF%84%E4%BC%B0-GC-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 评估 GC 的性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E8%AF%84%E4%BC%B0-GC-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%88Throughput%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 评估 GC 的性能指标：吞吐量（Throughput）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E8%AF%84%E4%BC%B0-GC-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%EF%BC%9A%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4%EF%BC%88pause-time%EF%BC%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 评估 GC 的性能指标：暂停时间（pause time）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E5%90%9E%E5%90%90%E9%87%8F-vs-%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 吞吐量 vs 暂停时间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">2.不同的垃圾回收器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-7-%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 7 款经典的垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-7-%E6%AC%BE%E7%BB%8F%E5%85%B8%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%88%86%E4%BB%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 7 款经典收集器与垃圾分代之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 垃圾收集器的组合关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 如何查看默认垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Serial-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">3.</span> <span class="nav-text">3.Serial 回收器：串行回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-ParNew-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">4.</span> <span class="nav-text">4.ParNew 回收器：并行回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Parallel-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-number">5.</span> <span class="nav-text">5.Parallel 回收器：吞吐量优先</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-CMS-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">6.</span> <span class="nav-text">6.CMS 回收器：低延迟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-CMS%E7%AE%80%E4%BB%8B"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 CMS简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-CMS%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 CMS运行原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">6.3.</span> <span class="nav-text">6.3优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4CMS-%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">6.4.</span> <span class="nav-text">6.4CMS 收集器可以设置的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-CMS%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 CMS的四个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%EF%BC%88initial-mark%EF%BC%89"><span class="nav-number">6.5.1.</span> <span class="nav-text">6.5.1 初始标记（initial mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%88Concurrent-Mark%EF%BC%89"><span class="nav-number">6.5.2.</span> <span class="nav-text">6.5.2 并发标记（Concurrent Mark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%EF%BC%88Remark%EF%BC%89"><span class="nav-number">6.5.3.</span> <span class="nav-text">6.5.3 重新标记（Remark）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-%E5%B9%B6%E5%8F%91%E5%9B%9E%E6%94%B6%EF%BC%88Concurrent-Sweep%EF%BC%89"><span class="nav-number">6.5.4.</span> <span class="nav-text">6.5.4 并发回收（Concurrent Sweep）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">6.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-G1-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">7.G1 回收器：区域化分代式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">7.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">7.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">7.3.</span> <span class="nav-text">参数设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="nav-number">7.4.</span> <span class="nav-text">G1 收集器的常见操作步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.5.</span> <span class="nav-text">G1 收集器的适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA-Region%EF%BC%9A%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="nav-number">7.6.</span> <span class="nav-text">分区 Region：化整为零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">7.7.</span> <span class="nav-text">G1 垃圾回收器的回收过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Remembered-Set%EF%BC%88%E8%AE%B0%E5%BF%86%E9%9B%86%EF%BC%89"><span class="nav-number">7.8.</span> <span class="nav-text">Remembered Set（记忆集）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%80%EF%BC%9A%E5%B9%B4%E8%BD%BB%E4%BB%A3-GC"><span class="nav-number">7.9.</span> <span class="nav-text">G1 回收过程一：年轻代 GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%BA%8C%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%BB%E8%A6%81%E9%92%88%E5%AF%B9%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%89"><span class="nav-number">7.10.</span> <span class="nav-text">G1 回收过程二：并发标记过程（主要针对老年代）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%89%EF%BC%9A%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="nav-number">7.11.</span> <span class="nav-text">G1 回收过程三：混合回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%9B%9E%E6%94%B6%E5%8F%AF%E9%80%89%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%9B%EF%BC%9AFull-GC"><span class="nav-number">7.12.</span> <span class="nav-text">G1 回收可选的过程四：Full GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1-%E5%9B%9E%E6%94%B6%E7%9A%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">7.13.</span> <span class="nav-text">G1 回收的优化建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">8.垃圾回收器总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 怎么选择垃圾回收器？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E5%92%8C%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">9.</span> <span class="nav-text">9. 三色标记和读写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">9.1三色标记算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">9.2 三色标记过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-3-%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%A2%E5%A4%B1"><span class="nav-number">10.</span> <span class="nav-text">9.3 三色标记算法的对象丢失</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">10.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SATB-%E5%8E%9F%E5%A7%8B%E5%BF%AB%E7%85%A7%EF%BC%88Snapshot-At-The-Beginning%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">SATB 原始快照（Snapshot-At-The-Beginning）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MOITY</p>
  <div class="site-description" itemprop="description">阿西吧</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MOITY">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MOITY个人">
      <meta itemprop="description" content="阿西吧">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | MOITY个人">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-25 21:03:07" itemprop="dateCreated datePublished" datetime="2022-07-25T21:03:07+08:00">2022-07-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-GC-分类与性能指标"><a href="#1-GC-分类与性能指标" class="headerlink" title="1.GC 分类与性能指标"></a>1.GC 分类与性能指标</h1><ul>
<li>  垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</li>
<li>  由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</li>
<li>  从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。<blockquote>
<p>Java 不同版本新特性</p>
<ol>
<li>语法层面：Lambda 表达式、switch、自动拆箱装箱、enum</li>
<li>API 层面：Stream API、新的日期时间、Optional、String、集合框架</li>
<li>底层优化：JVM 优化、GC 的变化、元空间、静态域、字符串常量池位置变化</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="1-1-垃圾收集器分类"><a href="#1-1-垃圾收集器分类" class="headerlink" title="1.1 垃圾收集器分类"></a>1.1 垃圾收集器分类</h2><h3 id="1-1-1-按线程数划分"><a href="#1-1-1-按线程数划分" class="headerlink" title="1.1.1 按线程数划分"></a>1.1.1 按线程数划分</h3><blockquote>
<p>按<strong>线程数</strong>分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p>
</blockquote>
<ul>
<li><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Client 模式下的 JVM 中。</li>
<li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
</li>
<li><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-The-World”机制。</p>
<h3 id="1-1-2-按工作模式分"><a href="#1-1-2-按工作模式分" class="headerlink" title="1.1.2 按工作模式分"></a>1.1.2 按工作模式分</h3><blockquote>
<p>按照<strong>工作模式</strong>分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p>
</blockquote>
</li>
<li><p>  并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</p>
</li>
<li><p>  独占式垃圾回收器（Stop The World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718151310.png"></p>
</li>
</ul>
<h3 id="1-1-3-按碎片处理方式分"><a href="#1-1-3-按碎片处理方式分" class="headerlink" title="1.1.3 按碎片处理方式分"></a>1.1.3 按碎片处理方式分</h3><blockquote>
<p>按<strong>碎片处理方式</strong>分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。</p>
</blockquote>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。<ul>
<li>  再分配对象空间：使用指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作。<ul>
<li>  再分配对象空间：空闲列表</li>
</ul>
</li>
</ul>
<h3 id="1-1-4-按工作的内存区间分"><a href="#1-1-4-按工作的内存区间分" class="headerlink" title="1.1.4 按工作的内存区间分"></a>1.1.4 按工作的内存区间分</h3><p>按<strong>工作的内存区间</strong>划分，又可分为年轻代垃圾回收器和老年代垃圾回收器</p>
<h2 id="1-2-评估-GC-的性能指标"><a href="#1-2-评估-GC-的性能指标" class="headerlink" title="1.2 评估 GC 的性能指标"></a>1.2 评估 GC 的性能指标</h2><ul>
<li>吞吐量：运行用户代码的时间占总运行时间的比例<ul>
<li>  （总运行时间 = 程序的运行时间 + 内存回收的时间）</li>
</ul>
</li>
<li>  垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li>  暂停时间：执行垃圾收集时，程序的工作线程 (用户线程) 被暂停的时间。</li>
<li>  收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>  内存占用：Java 堆区所占的内存大小。</li>
<li>  快速：一个对象从诞生到被回收所经历的时间。</li>
<li>  吞吐量、暂停时间、内存占用，这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>  这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：<ul>
<li>  吞吐量</li>
<li>  暂停时间</li>
</ul>
</li>
</ul>
<h3 id="1-2-1-评估-GC-的性能指标：吞吐量（Throughput）"><a href="#1-2-1-评估-GC-的性能指标：吞吐量（Throughput）" class="headerlink" title="1.2.1 评估 GC 的性能指标：吞吐量（Throughput）"></a>1.2.1 评估 GC 的性能指标：吞吐量（Throughput）</h3><ul>
<li>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）<ul>
<li>  比如：虚拟机总共运行了100 分钟，其中垃圾收集花掉1分钟，那吞吐量就是 99%。</li>
</ul>
</li>
<li>  这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应 (暂停时间) 是不必考虑的</li>
<li>  吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</li>
<li><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718153041.png"></li>
</ul>
<h3 id="1-2-2-评估-GC-的性能指标：暂停时间（pause-time）"><a href="#1-2-2-评估-GC-的性能指标：暂停时间（pause-time）" class="headerlink" title="1.2.2 评估 GC 的性能指标：暂停时间（pause time）"></a>1.2.2 评估 GC 的性能指标：暂停时间（pause time）</h3><ul>
<li>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。<ul>
<li>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718153047.png"><h3 id="1-2-3-吞吐量-vs-暂停时间"><a href="#1-2-3-吞吐量-vs-暂停时间" class="headerlink" title="1.2.3 吞吐量 vs 暂停时间"></a>1.2.3 吞吐量 vs 暂停时间</h3></li>
<li>  高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li>
<li>  低暂停时间（低延迟）较好是因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。<ul>
<li>  因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li>
<li>  相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又<strong>引起了年轻代内存的缩减和导致程序吞吐量的下降</strong>。</li>
</ul>
</li>
<li>  在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</li>
<li>  现在标准：在最大吞吐量优先的情况下，降低停顿时间<h1 id="2-不同的垃圾回收器概述"><a href="#2-不同的垃圾回收器概述" class="headerlink" title="2.不同的垃圾回收器概述"></a>2.不同的垃圾回收器概述</h1>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li>
</ul>
<p>那么，Java 常见的垃圾收集器有哪些？</p>
<blockquote>
<p>GC 垃圾收集器是和 JVM 一脉相承的，它是和 JVM 进行搭配使用，在不同的使用场景对应的收集器也是有区别</p>
</blockquote>
<h2 id="2-1-7-款经典的垃圾收集器"><a href="#2-1-7-款经典的垃圾收集器" class="headerlink" title="2.1 7 款经典的垃圾收集器"></a>2.1 7 款经典的垃圾收集器</h2><ul>
<li><p>  串行回收器：Serial、Serial Old</p>
</li>
<li><p>  并行回收器：ParNew、Parallel Scavenge、Parallel Old</p>
</li>
<li><p>  并发回收器：CMS、G1</p>
<h2 id="2-2-7-款经典收集器与垃圾分代之间的关系"><a href="#2-2-7-款经典收集器与垃圾分代之间的关系" class="headerlink" title="2.2 7 款经典收集器与垃圾分代之间的关系"></a>2.2 7 款经典收集器与垃圾分代之间的关系</h2><p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718154118.png"></p>
</li>
<li><p>  新生代收集器：Serial、ParNew、Parallel Scavenge；</p>
</li>
<li><p>  老年代收集器：Serial Old、Parallel Old、CMS；</p>
</li>
<li><p>  整堆收集器：G1；</p>
<h2 id="2-3-垃圾收集器的组合关系"><a href="#2-3-垃圾收集器的组合关系" class="headerlink" title="2.3 垃圾收集器的组合关系"></a>2.3 垃圾收集器的组合关系</h2></li>
</ul>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718154141.png"></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>
<li>其中 Serial Old 作为 CMS 出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial + CMS、ParNew + Serial Old 这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）。</li>
<li>（青色虚线）JDK 14 中：删除 CMS 垃圾回收器（JEP363）。</li>
</ul>
<blockquote>
<p>为什么 CMS GC 不可以和 Parallel Scavenge GC 搭配使用？</p>
</blockquote>
<p>答：Parallel Scavenge GC 底层框架和其他垃圾回收器不同。</p>
<ul>
<li>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</li>
<li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。<h2 id="2-4-如何查看默认垃圾收集器"><a href="#2-4-如何查看默认垃圾收集器" class="headerlink" title="2.4 如何查看默认垃圾收集器"></a>2.4 如何查看默认垃圾收集器</h2></li>
<li>  <code>XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>  使用命令行指令：<code>jinfo -flag</code> 相关垃圾回收器参数、进程 ID3</li>
</ul>
<h1 id="3-Serial-回收器：串行回收"><a href="#3-Serial-回收器：串行回收" class="headerlink" title="3.Serial 回收器：串行回收"></a>3.Serial 回收器：串行回收</h1><ul>
<li>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK 1.3 之前回收新生代唯一的选择。</li>
<li>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。</li>
<li>Serial 收集器采用复制算法、串行回收和”Stop-The-World”机制的方式执行内存回收。</li>
<li>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和”Stop The World”机制，只不过内存回收算法使用的是标记-压缩算法<strong>。</strong><ul>
<li>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial Old 在 Server 模式下主要有两个用途：<ul>
<li>与新生代的 Parallel Scavenge 配合使用</li>
<li>作为老年代 CMS 收集器的后备垃圾收集方案<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718160558.png"></li>
</ul>
</li>
</ul>
</li>
<li>  这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。</li>
<li>优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。<ul>
<li>  运行在 Client 模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li>  在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>在 HotSpot 虚拟机中，使用 <code>-XX:+UseSerialGC</code> 参数可以指定年轻代和老年代都使用串行收集器。<ul>
<li>  等价于新生代用 Serial GC，且老年代用 Serial Old GC。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p>  这种垃圾收集器大家都了解，现在已经不用串行的了。而且在限定单核 CPU 才可以用。现在都不是单核的了。</p>
</li>
<li><p>  对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java Web 应用程序中是不会采用串行垃圾收集器的。</p>
<h1 id="4-ParNew-回收器：并行回收"><a href="#4-ParNew-回收器：并行回收" class="headerlink" title="4.ParNew 回收器：并行回收"></a>4.ParNew 回收器：并行回收</h1></li>
<li><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。</p>
<ul>
<li>  Par 是 Parallel 的缩写，New：只能处理的是新生代</li>
</ul>
</li>
<li><p>  ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、”Stop-The-World”机制。</p>
</li>
<li><p>  ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718214825.png"></p>
</li>
<li><p>  对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>  对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）。</p>
</li>
<li><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p>
<ul>
<li>  ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>  但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁得做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
</li>
<li><p>除 Serial Old GC 外，目前只有 ParNew GC 能与 CMS 收集器配合工作（JDK 8 中 Serial Old GC 移除对 ParNew GC 的支持，JDK 9 版本中已经明确提示 UserParNewGC was deprecated，将在后续版本中被移除，JDK 14 中移除 CMS GC）。</p>
</li>
<li><p>在程序中，开发人员可以通过选项<code>-XX:+UseParNewGC</code>手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li><p><code>-XX:ParallelGCThreads</code> 限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
<h1 id="5-Parallel-回收器：吞吐量优先"><a href="#5-Parallel-回收器：吞吐量优先" class="headerlink" title="5.Parallel 回收器：吞吐量优先"></a>5.Parallel 回收器：吞吐量优先</h1></li>
<li><p>  HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和”Stop The World”机制。</p>
</li>
<li><p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>  和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li>  自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
</li>
<li><p>  高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>  Parallel 收集器在 JDK 1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
</li>
<li><p>  Parallel Old 收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-The-World”机制。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220718221136.png"></p>
</li>
<li><p>  在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。</p>
</li>
<li><p>  在 Java 8 中，默认是此垃圾收集器。</p>
<blockquote>
<p>参数配置</p>
</blockquote>
</li>
<li><p>  <code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p>
</li>
<li><p><code>-XX:+UseParalleloldGC</code> 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认 JDK 8 是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
</li>
<li><p><code>-XX:ParallelGcrhreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能</p>
<ul>
<li>在默认情况下，当 CPU 数量小于 等于8 个，ParallelGCThreads 的值等于 CPU 数量。</li>
<li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 <code>3 + [5 * CPU_Count] / 8]</code></li>
</ul>
</li>
<li><p><code>XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒。</p>
<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li>
<li>该参数使用需谨慎。</li>
</ul>
</li>
<li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（= 1 /（N+1））。用于衡量吞吐量的大小。</p>
<ul>
<li>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1%</li>
<li>与前一个 <code>-XX:MaxGCPauseMillis</code> 参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li>
</ul>
</li>
<li><p><code>-XX:+UseAdaptiveSizePolicy</code> 设置 Parallel Scavenge 收集器具有自适应调节策略。</p>
<ul>
<li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。<h1 id="6-CMS-回收器：低延迟"><a href="#6-CMS-回收器：低延迟" class="headerlink" title="6.CMS 回收器：低延迟"></a>6.CMS 回收器：低延迟</h1></li>
</ul>
</li>
<li><p>  在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
</li>
<li><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li>  目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li><p>  CMS 的垃圾收集算法采用标记-清除算法，并且也会”Stop-The-World”。</p>
</li>
<li><p>  不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
</li>
<li><p>  在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719101136.png"></p>
<blockquote>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及 STW 的阶段主要是：初始标记和重新标记)</p>
</blockquote>
</li>
<li><p><strong>初始标记（Initial-Mark）阶段：</strong> 在这个阶段中，程序中所有的工作线程 (用户线程) 都将会因为“Stop-The-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
</li>
<li><p><strong>并发标记（Concurrent-Mark）阶段：</strong> 从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p><strong>重新标记（Remark）阶段：</strong> 由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li><p><strong>并发清除（Concurrent-Sweep）阶段：</strong> 此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
</li>
<li><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-The-World”，只是尽可能地缩短暂停时间。</p>
</li>
<li><p><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</strong></p>
</li>
<li><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。<strong>因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。</strong> 要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
</li>
<li><p>CMS 收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719101216.png"></p>
<blockquote>
<p>CMS 为什么不使用标记整理（压缩）算法？</p>
</blockquote>
</li>
</ul>
<p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响。Mark Compact 更适合“Stop The World”这种场景下使用。</p>
<h2 id="6-1-CMS简介"><a href="#6-1-CMS简介" class="headerlink" title="6.1 CMS简介"></a>6.1 CMS简介</h2><ol>
<li>回收方式<ol>
<li>标记-清除算法</li>
<li>并发回收</li>
<li>STW机制</li>
</ol>
</li>
<li>回收区域<ol>
<li>老年代</li>
</ol>
</li>
<li>应用场景<ol>
<li><strong>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间</strong>。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验</li>
<li>前很大一部分的Java应用集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS收集器非常符合这类应用的需求3</li>
</ol>
</li>
<li>优点<ol>
<li>并发收集</li>
<li>低延迟</li>
</ol>
</li>
<li>弊端<ol>
<li><strong>会产生内存碎片</strong>，导致并发清除过后，用户线程可用空间不足。在无法分配大对象的情况下，不得不提前触发Full GC</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是回因为占用了一部分线程和而导致应用程序变慢，总吞吐量会降低</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>，可能出现”Concurrent Mode Failure”失败而导致另一次完全”Stop-the-world”的Full GC的产生。<strong>在并发标记和并发清理阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行处理</strong>，最终会导致这些新产生的垃圾对象<strong>没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间，这一部分垃圾就被称为浮动垃圾。</li>
</ol>
</li>
</ol>
<h2 id="6-2-CMS运行原理"><a href="#6-2-CMS运行原理" class="headerlink" title="6.2 CMS运行原理"></a>6.2 CMS运行原理</h2><ul>
<li>尽管CMS收集器采用的是并发回收(非独占式)，但是在其初始化标记和重新标记这两个阶段中仍然需要执行”Stop-the-world”机制暂停程序中的工作线程，不过暂停时间不会太长，因此目前所有的垃圾收集器都做不到完全不需要”Stop-the-world”，只是尽可能的缩短暂停时间</li>
<li>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</li>
<li><strong>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<strong>当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行，<strong>要是CMS运行期间预留的内存无法满足程序需要</strong>，就会出现一次**”Concurrent Mode Failure”<strong>失败，这时虚拟机将</strong>启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集**，这样停顿时间就很长了。</li>
<li><strong>为什么CMS使用标记-清除而不是标记-压缩（整理）算法</strong><ul>
<li>因为当并发清除时，用户线程并没有中断，用Compact整理内存的话，原理的用户线程使用的内存还怎么用？ 要保证用户线程能够执行，前提是它的运行资源不受影响。<strong>Mark Compact更适合”Stop-the-world”这种场景下使用</strong></li>
</ul>
</li>
<li></li>
</ul>
<h2 id="6-3优缺点"><a href="#6-3优缺点" class="headerlink" title="6.3优缺点"></a>6.3优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>会产生内部碎片，导致并发清除后，用户线程可用空间不足。在无法分配大对象的情况下，不得不提前触发Full GC</li>
<li>CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><strong>CMS 收集器无法处理浮动垃圾。</strong> 可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。<h2 id="6-4CMS-收集器可以设置的参数"><a href="#6-4CMS-收集器可以设置的参数" class="headerlink" title="6.4CMS 收集器可以设置的参数"></a>6.4CMS 收集器可以设置的参数</h2></li>
<li><code>-XX:+UseConcMarkSweepGC</code> 手动指定使用 CMS 收集器执行内存回收任务。<ul>
<li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：ParNew（Young 区用）+ CMS（Old 区用）+ Serial Old 的组合。</li>
</ul>
</li>
<li><code>-XX:CMSInitiatingoccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK 5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。JDK 6 及以上版本默认值为 92%</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Full GC 的执行次数。</li>
</ul>
</li>
<li><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li>
<li><code>-XX:CMSFullGCsBeforecompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理</li>
<li><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量<ul>
<li>CMS 默认启动的线程数是<code>（ParallelGCThreads + 3）/ 4</code>，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li>
</ul>
</li>
</ul>
<h2 id="6-5-CMS的四个阶段"><a href="#6-5-CMS的四个阶段" class="headerlink" title="6.5 CMS的四个阶段"></a>6.5 CMS的四个阶段</h2><h3 id="6-5-1-初始标记（initial-mark）"><a href="#6-5-1-初始标记（initial-mark）" class="headerlink" title="6.5.1 初始标记（initial mark）"></a>6.5.1 初始标记（initial mark）</h3><p>第一个阶段叫做初始标记，意思是先通过我们GC Roots来找到根对象，然后第一个阶段就结束了，但注意他是<strong>Stop the world</strong>，不过即使是STW，因为我们找的根对象特别少，所以它的STW时间非常短</p>
<h3 id="6-5-2-并发标记（Concurrent-Mark）"><a href="#6-5-2-并发标记（Concurrent-Mark）" class="headerlink" title="6.5.2 并发标记（Concurrent Mark）"></a>6.5.2 并发标记（Concurrent Mark）</h3><p>第二个阶段叫concurrent mark并发标记，并发标记会发生很多次，与此同时我们在病发的时候，我们其他的工作线程也在不断改变的这些引用的它的指向，这时候就非常容易出错，他是最耗时间的阶段，并发执行了，这时候它不产生STW，他就对用户的响应就比较及时，他到底怎么做的？找到根上对象之后，这个阶段叫并发标记也是最耗时的一个阶段，它把最耗时的一个阶段并发执行了，和我们工作线程一块儿执行，这时候不产生STW，对于用户的响应就比较及时，怎么做的呢？ 他会从根对象继续往下找，但是找的过程之中很有可能会发生一件事，就是原来那个垃圾被我加了一个引用他就不是垃圾了，我就不会把他给回收掉，如果说是在我并发标记过程之中它变成不是垃圾的，<strong>这个时候就会进入remark阶段重新标记</strong>，标记那些在我上一个阶段改的过程中改的这些对象，因为应用改的不是特别多，remark也是个STW的过程，不过他的时间也不长，所以他就可以有效的控制暂停时间。</p>
<h3 id="6-5-3-重新标记（Remark）"><a href="#6-5-3-重新标记（Remark）" class="headerlink" title="6.5.3 重新标记（Remark）"></a>6.5.3 重新标记（Remark）</h3><p>从垃圾变成不是垃圾的，把漏标的重新标记，虽然他是STW，但是时间不长，远远比并发标记的时间短</p>
<h3 id="6-5-4-并发回收（Concurrent-Sweep）"><a href="#6-5-4-并发回收（Concurrent-Sweep）" class="headerlink" title="6.5.4 并发回收（Concurrent Sweep）"></a>6.5.4 并发回收（Concurrent Sweep）</h3><p>把不用的垃圾回收，回收的过程中产生新垃圾，也就是浮动垃圾，他会在下一轮进行回收</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？</strong></p>
<ul>
<li>  如果想要最小化地使用内存和并行开销，选 Serial GC；</li>
<li>  如果想要最大化应用程序的吞吐量，选 Parallel GC；</li>
<li>  如果想要最小化 GC 的中断或停顿时间，选 CMS GC。</li>
</ul>
<h1 id="7-G1-回收器：区域化分代式"><a href="#7-G1-回收器：区域化分代式" class="headerlink" title="7.G1 回收器：区域化分代式"></a>7.G1 回收器：区域化分代式</h1><blockquote>
<p>为什么名字叫 Garbage First（G1）呢？</p>
</blockquote>
<ul>
<li>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</li>
<li>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</li>
<li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</li>
<li>在 JDK 1.7 版本正式启用，移除了 Experimental 的标识，是 JDK 9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel + Parallel Old 组合。被 Oracel 官方称为“全功能的垃圾收集器”。</li>
<li>与此同时，CMS 已经在 JDK 9 中被标记为废弃（Deprecated）。在 JDK 8 中还不是默认的垃圾回收器，需要使用 <code>-XX:+UseG1GC</code> 来启用</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>与其他 GC 收集器相比，G1 使用了全新的分区算法，其特点如下所示：</p>
<blockquote>
<p>并行与并发</p>
</blockquote>
<ul>
<li>  并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW。</li>
<li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
<blockquote>
<p>分代收集</p>
</blockquote>
<ul>
<li>  从分代上看，G1 依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>  将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>  和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
<li>  G1 所谓的分代，已经不是下面这样的了</li>
</ul>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719105418.png"></p>
<blockquote>
<p>而是这样的一个区域</p>
</blockquote>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719105436.png"></p>
<blockquote>
<p>空间整合</p>
</blockquote>
<ul>
<li>  CMS：“标记-清除” 算法、内存碎片、若干次 GC 后进行一次碎片整理</li>
<li>  G1 将内存划分为一个个的 Region。内存的回收是以 Region 作为基本单位的。Region 之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性 有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li>
</ul>
<blockquote>
<p>可预测的停顿时间模型（即：软实时 Soft Real-Time）</p>
</blockquote>
<ul>
<li>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。<ul>
<li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region 。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>  相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</li>
<li>  从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6~8GB 之间。</li>
</ul>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到），默认值是 200ms</li>
<li><code>-XX:+ParallelGcThread</code>：设置 STW 时GC线程数的值，最多设置为 8</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC，默认值是 45</li>
</ul>
<h2 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h2><ul>
<li>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：<ul>
<li>  第一步：开启 G1 垃圾收集器</li>
<li>  第二步：设置堆的最大内存</li>
<li>  第三步：设置最大的停顿时间</li>
</ul>
</li>
<li>  G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发。</li>
</ul>
<h2 id="G1-收集器的适用场景"><a href="#G1-收集器的适用场景" class="headerlink" title="G1 收集器的适用场景"></a>G1 收集器的适用场景</h2><ul>
<li><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
</li>
<li><p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；</p>
</li>
<li><p>如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p>
</li>
<li><p>用来替换掉 JDK 1.5 中的 CMS 收集器；</p>
<ul>
<li>在下面的情况时，使用 G1 可能比 CMS 好：<ul>
<li>超过 50% 的 Java </li>
<li>堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC 停顿时间过长（长于 0.5 至 1 秒）</li>
</ul>
</li>
</ul>
</li>
<li><p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h2 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h2></li>
<li><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB、2MB、4MB、8MB、16MB、32MB。可以通过 <code>-XX:G1HeapRegionSize</code> 设定。所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</p>
</li>
<li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合，通过 Region 的动态分配方式实现逻辑上的连续<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719145208.png"></p>
</li>
<li><p>一个 Region 有可能属于 Eden、Survivor 或者 Old/Tenured 内存区域。但是一个 Region 只可能属于一个角色。图中的 E 表示该 Region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 Region，就放到 H。</p>
<blockquote>
<p>设置 H 的原因：</p>
</blockquote>
</li>
</ul>
<p>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p>
<blockquote>
<p>每个 Region 都是通过指针碰撞来分配空间</p>
</blockquote>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719145302.png"></p>
<h2 id="G1-垃圾回收器的回收过程"><a href="#G1-垃圾回收器的回收过程" class="headerlink" title="G1 垃圾回收器的回收过程"></a>G1 垃圾回收器的回收过程</h2><blockquote>
<p>G1 GC 的垃圾回收过程主要包括如下三个环节：</p>
</blockquote>
<ul>
<li><p>年轻代 GC（Young GC）</p>
</li>
<li><p>老年代并发标记过程（Concurrent Marking）</p>
</li>
<li><p>混合回收（Mixed GC）</p>
</li>
<li><p>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719145333.png"></p>
</li>
<li><p>顺时针，Young GC -&gt; Young GC + Concurrent Mark -&gt; Mixed GC 顺序，进行垃圾回收。</p>
</li>
<li><p>应用程序分配内存，当年轻代的 Eden 区用尽时开始年轻代回收过程；G1 的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。</p>
</li>
<li><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p>
</li>
<li><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了。同时，这个老年代 Region 是和年轻代一起被回收的。</p>
</li>
<li><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h2 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h2></li>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中的对象所引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代？</p>
</li>
<li><p>这样的话会降低 Minor GC 的效率。</p>
</li>
<li><p>解决方法：</p>
<ul>
<li>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：</li>
<li>每个 Region 都有一个对应的 Remembered Set ；</li>
<li>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier (写屏障) 暂时中断操作；</li>
<li>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li>
<li>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</li>
<li>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719151759.png"></li>
</ul>
</li>
</ul>
<h2 id="G1-回收过程一：年轻代-GC"><a href="#G1-回收过程一：年轻代-GC" class="headerlink" title="G1 回收过程一：年轻代 GC"></a>G1 回收过程一：年轻代 GC</h2><ul>
<li>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。<ul>
<li>注意：Survivor 区不会主动启动垃圾回收，只能是被动的跟随Eden区进行垃圾回收</li>
</ul>
</li>
<li>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</li>
<li>YGC时，首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</li>
</ul>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719154049.png"></p>
<blockquote>
<p>然后开始如下回收过程：</p>
</blockquote>
<ul>
<li>第一阶段，扫描根<ul>
<li>根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet（记忆集） 记录的外部引用作为扫描存活对象的入口。</li>
</ul>
</li>
<li>第二阶段，更新 RSet<ul>
<li>处理 Dirty Card Queue（见备注）中的 Card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中 ( 主要指新生代) 对象的引用。</li>
<li>备注：对于应用程序的引用赋值语句 (老年代) object.field = object (新生代) ，JVM 会在代码执行之前和之后执行特殊的操作以在 Dirty Card Queue 中入队一个保存了对象引用信息的 Card。在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 Card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系。<ul>
<li>那为什么不在引用赋值语句处直接更新 RSet 呢？<ul>
<li>这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
</li>
</ul>
</li>
<li>第三阶段，处理 RSet（记忆集）<ul>
<li>识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
</ul>
</li>
<li>第四阶段，复制对象（复制算法）<ul>
<li>此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li>
</ul>
</li>
<li>第五阶段，处理引用<ul>
<li>处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。<h2 id="G1-回收过程二：并发标记过程（主要针对老年代）"><a href="#G1-回收过程二：并发标记过程（主要针对老年代）" class="headerlink" title="G1 回收过程二：并发标记过程（主要针对老年代）"></a>G1 回收过程二：并发标记过程（主要针对老年代）</h2></li>
</ul>
</li>
</ul>
</li>
<li>初始标记阶段：标记从根节点能够直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li>
<li>根区域扫描（Root Region Scanning）：G1 GC 扫描 Survivor 区可以直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成。</li>
<li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能会被 Young GC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果，这个过程是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：Snapshot-At-The-Beginning（SATB）。</li>
<li>独占清理（cleanup，STW）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。这个过程是 STW 的。<ul>
<li>这个阶段并不会实际上去做垃圾的收集。</li>
</ul>
</li>
<li>并发清理阶段：识别并清理完全空闲的区域。<h2 id="G1-回收过程三：混合回收"><a href="#G1-回收过程三：混合回收" class="headerlink" title="G1 回收过程三：混合回收"></a>G1 回收过程三：混合回收</h2></li>
<li>当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC</li>
<li>该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region</li>
<li>这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。</li>
<li>也要注意的是 Mixed GC 并不是 Full GC。<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719154419.png"></li>
</ul>
<blockquote>
<p>整个过程都是复制算法，不会产生内存碎片</p>
</blockquote>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过 <code>-XX:G1MixedGCCountTarget</code> 设置）被回收</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程</li>
<li>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收， <code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65% 才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</li>
<li>混合回收并不一定要进行 8 次。有一个阈值 <code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少<h2 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h2></li>
<li>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li>
<li>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC ，这种情况可以通过增大内存解决。</li>
<li>导致 G1 Full GC 的原因可能有两个：<ul>
<li>Evacuation ( 回收) 的时候没有足够的 To-Space 来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
</li>
</ul>
<h2 id="G1-回收的优化建议"><a href="#G1-回收的优化建议" class="headerlink" title="G1 回收的优化建议"></a>G1 回收的优化建议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回收一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</span><br></pre></td></tr></table></figure>
<ul>
<li>年轻代大小<ul>
<li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
</li>
<li>暂停时间目标暂停时间目标不要太过严苛<ul>
<li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间</li>
<li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ul>
<h1 id="8-垃圾回收器总结"><a href="#8-垃圾回收器总结" class="headerlink" title="8.垃圾回收器总结"></a>8.垃圾回收器总结</h1><blockquote>
<p>截止 JDK 1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
</blockquote>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719163120.png"><br><strong>记忆小技巧：年轻代都是复制算法，老年代除了CMS是标记清除算法之外，其他都是标记压缩算法</strong></p>
<ul>
<li>GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</li>
<li>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合（连线）如下图：（更新到了JDK14）<br><img src="http://moity-bucket.moity-soeoe.xyz/img/20220719163143.png"></li>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1。</li>
<li>其中 Serial Old 作为 CMS 出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial + CMS、ParNew + Serial Old 这两个组合声明为废弃（JEP173），并在 JDK 9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）。</li>
<li>（青色虚线）JDK 14 中：删除 CMS 垃圾回收器（JEP363）。<h2 id="8-1-怎么选择垃圾回收器？"><a href="#8-1-怎么选择垃圾回收器？" class="headerlink" title="8.1 怎么选择垃圾回收器？"></a>8.1 怎么选择垃圾回收器？</h2></li>
<li>  Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</li>
</ul>
<blockquote>
<p>怎么选择垃圾收集器？</p>
</blockquote>
<ul>
<li><p>优先调整堆的大小让 JVM 自适应完成。</p>
</li>
<li><p>如果内存小于 100M，使用串行收集器。</p>
</li>
<li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器。</p>
</li>
<li><p>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择。</p>
</li>
<li><p>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器。</p>
<ul>
<li>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。<blockquote>
<p>最后需要明确一个观点：</p>
</blockquote>
</li>
</ul>
</li>
<li><p>  没有最好的收集器，更没有万能的收集</p>
</li>
<li><p>  调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</p>
</li>
</ul>
<h1 id="9-三色标记和读写屏障"><a href="#9-三色标记和读写屏障" class="headerlink" title="9. 三色标记和读写屏障"></a>9. 三色标记和读写屏障</h1><h2 id="9-1三色标记算法"><a href="#9-1三色标记算法" class="headerlink" title="9.1三色标记算法"></a>9.1三色标记算法</h2><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性。</p>
<p>因为在并发标记期间应用线程还在继续跑，对象间的引用可能发生变化，**多标 **和 <strong>漏标</strong> 的情况还可能发生。</p>
<p><img src="http://moity-bucket.moity-soeoe.xyz/img/ef465d703c93e5b923776ca6469efe63.gif"></p>
<p>我们将对象分为三种类型：</p>
<ul>
<li>黑色：<ul>
<li>根对象，或者该对象与它的子对象全都被扫描过（对象被标记了，且它的所有field也被标记完了）</li>
</ul>
</li>
<li>灰色：<ul>
<li>对象本身被扫描，还没有扫描完该对象中的子对象（它的field还没有被标记或者标记完）</li>
</ul>
</li>
<li>白色：<ul>
<li>未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象（对象没有被标记到）</li>
</ul>
</li>
</ul>
<h2 id="9-2-三色标记过程"><a href="#9-2-三色标记过程" class="headerlink" title="9.2 三色标记过程"></a>9.2 三色标记过程</h2><ol>
<li>三色标记算法，如果将根对象设置为黑色，那么下级节点的为灰色，再下面的的为白色</li>
<li>灰色扫描完毕后，那么剩下的白色变为灰色</li>
<li>灰色扫描完毕后，那么全部被标记为黑色，不可达的还是为白色</li>
</ol>
<h1 id="9-3-三色标记算法的对象丢失"><a href="#9-3-三色标记算法的对象丢失" class="headerlink" title="9.3 三色标记算法的对象丢失"></a>9.3 三色标记算法的对象丢失</h1><ul>
<li>但是如果标记过程中，应用进程也在同步执行，那么对象的指针就有可能改变，我们就会遇到<strong>对象丢失</strong>的问题</li>
<li><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.c = C;</span><br><span class="line">B.c = <span class="literal">null</span>;  </span><br></pre></td></tr></table></figure>
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始状态：</span><br><span class="line">GC Roots -&gt; A(黑)</span><br><span class="line">Gc Roots -&gt; B(灰) -&gt; C(白)</span><br><span class="line"></span><br><span class="line">在标记过程中执行了上面的代码</span><br><span class="line">导致状态变为：</span><br><span class="line">GC Roots -&gt; A(黑) -&gt; C(白)</span><br><span class="line">GC Roots -&gt; B(黑)</span><br><span class="line"></span><br><span class="line">导致C被清除了</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="SATB-原始快照（Snapshot-At-The-Beginning）"><a href="#SATB-原始快照（Snapshot-At-The-Beginning）" class="headerlink" title="SATB 原始快照（Snapshot-At-The-Beginning）"></a>SATB 原始快照（Snapshot-At-The-Beginning）</h1><p>ATB是维持并发GC的一种手段。G1并发的基础就是SATB。SATB可以理解成在GC开始之前对堆内存里的对象做一次快照，此时活的对象就认为是活的，从而形成一个对象图</p>
<p>在GC收集的时候，新生代的对象也认为是活的对象，除此之外其他不可达的对象也认为是垃圾对象。</p>
<p>如何找到在GC过程分配的对象呢？每个region记录着两个top-at-mark-start(TAMS) 指针，分别为prevTAMS 和nextTAMS。在TAMS以上的独享就是新分配的，因而被视为隐式marked</p>
<p>通过这种方式我们就找到了再GC过程中新分配的对象，并把这些对象认为是活的对象。</p>
<p>解决了对象在GC过程中分配的问题，呢么GC过程中引用频繁变化的问题是怎么解决的呢？</p>
<p>G1给出的解决办法是通过Write Barrier. Write Barrier 就是堆引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到哪些引用对象发生了什么样的变化</p>
<p>mark 的过程就是遍历heap标记live object的过程，采用的三色标记算法，这三种颜色为white（表示还未访问到）、gray（访问到但是它用到的引用还诶有完全扫描）、black (访问到而且其用到的引用完全扫描完)</p>
<p>整个三色标记算法就是从GC Roots出发遍历heap，针对可达对象先标记white为gray， 然后再标记gray为black; 遍历完成之后所有可达对象都是black的，所有white 都是可以回收的。</p>
<p>SATB仅仅对于在marking开始阶段进行”snapshot”（marked all reachable at mark start), 但是concurrent 的时候并发修改可能造成对象漏标记</p>
<blockquote>
<p>为什么G1使用STAB？ CMS使用增量更新</p>
</blockquote>
<p>STAB 相对增量更新效率会很高（当然 STAB 可能造成更多的浮动垃圾），因为不需要重新标记再次深度扫描被删除引用对象，而 CMS 对增量引用的根对象会做深度扫描， G1 因为很多对象都是位于不同的 region ，CMS 是一块老年代区域，重新深度扫描对象的话 G1 的代价会比 CMS 高， 所以 G1 选择 STAB 不深度扫描对象，只是简单标记， 等到下一轮 GC 再深度扫描。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/25/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="prev" title="">
                  <i class="fa fa-chevron-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/25/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MOITY</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
